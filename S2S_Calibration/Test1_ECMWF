#!/usr/bin/env python
# coding: utf-8
### Script for doing bias correction. Target year, which initialisation (1 to 4) and target month will be system/cmndline argument, so we can run this using sbatch. The 'historic' period will always be years 2003 to 2019.

import os
import sys
from netCDF4 import Dataset, num2date
import numpy as np
# from scipy.stats import linregress
import matplotlib.pyplot as plt
sys.path.append("/mnt/lustre01/pf/a/a270138/Scripts/ForecastCalibration/TAQM_Method")
from taqm import taqm
from beinf import beinf


#
# data_path ='/work/ba1138/a270112/awicm3/FCST_CLIM/'
# save_path = '/work/ba1138/a270138/BiasCorrOutput/TAQMResults/'
#
#
# trust_sharp_fcst = False
#
#
# # Which year are we targetting? And what month?
# # python filenam.py 2015 1 6
# targetyear = int(sys.argv[1])
# leadtimeMonth = int(sys.argv[3])  #Leadtime, in month
# # whichinit=1#
# whichinit = int(sys.argv[2])  #Must be within 1 to 4
# # histYrs=np.arange(2003,2011)
# histYrs=np.arange(2003,targetyear)  # Now let's include all years until target within hist
# obsTyr=targetyear
#
# ## The target of the leadtime should change according to which initialisation.
# strtm = (1, 4, 7, 10)  # which is the starting month for each initialisation
# obsTmnth = leadtimeMonth+strtm[whichinit-1]-1
# if (obsTmnth>12):
#     obsTyr=obsTyr+1
#     obsTmnth=obsTmnth-12
#
# print('Targetyear = '+str(targetyear)+',initialisation = '+str(whichinit)+' which means from '+ str(strtm[whichinit-1]) +',leadtime '+str(leadtimeMonth)+' so target month is '+str(obsTmnth)+' of year '+str(obsTyr))  # Testing
#
# Grdlen = 126858  # For now we are pre-setting these. Dims[3] = 126858
# EMlen = 10  # Dims[0]  #30 Ensemble Members
# fcst_target = np.empty((EMlen,12,Grdlen))
# ## First let's save targetFcst
# yr=str(targetyear-2000)       # current year
# # file_anom0 = Dataset(data_path+'F'+str(yr)+'_MEM_ens_mon_mean_corr.nc')
# for EM in np.arange(EMlen):
#     file_anom0 = Dataset(data_path+'F'+str(yr).zfill(2)+str(whichinit)+'_ens_mon_mean/SIC_mon_'+str(EM+1).zfill(2)+'.nc')
#     temp=file_anom0.variables['a_ice'][:]
#     fcst_target[EM,:,:]=temp
#     file_anom0.close()
#     del temp
#
# #plt.plot(fcst_anom[1,1,1,])
# #plt.show()
#
#
# ## Observation for the date already exists?
# file_osisaf = Dataset('/work/ab0995/a270112/data_fesom2/sic/OSISAF_monthly_'+str(obsTyr)+'.nc')
# truobs=file_osisaf.variables['obs'][obsTmnth-1,:]
# file_osisaf.close()
#
# rawFcstCRPSS=np.empty(Grdlen)
# calFcstCRPSS=np.empty(Grdlen)
#
# obsSIP = np.empty(Grdlen) * np.nan
# rawSIP = np.empty(Grdlen)
# calSIP = np.empty(Grdlen)
#
# ## Let's save Historical Forecast, for only month 2 of forecast 1 of each year in histYRs for now
# histFcst=np.empty((len(histYrs),EMlen,Grdlen))
#
# for c,year in  enumerate(histYrs):
#     #print(year)
#     yr=str(year-2000)       # current year
#     lyr=str(year-1-2000)    # last year
#     for EM in np.arange(EMlen):
#         file_anom0 = Dataset(data_path+'F'+str(yr).zfill(2)+str(whichinit)+'_ens_mon_mean/SIC_mon_'+str(EM+1).zfill(2)+'.nc')
#         temp=file_anom0.variables['a_ice'][:]
#         histFcst[c,EM,:]=temp[leadtimeMonth-1,:]
#         file_anom0.close()
#         del temp
#
#
#
#     # file_anom = Dataset(data_path+'F'+str(yr)+'_MEM_ens_mon_mean_corr.nc')
#     # fcst_anom=file_anom.variables['SIC_FCST_CORR'][:]
#     # histFcst[c,:,:]=fcst_anom[:,1,leadtimeMonth-1,:]
#     # file_anom.close()
#
#
#
# ## Similarly, let's save Historical observation, for only Feb of each year in histYRs for now
# histYrsforObs=histYrs
# if (obsTyr>targetyear):
#     histYrsforObs=np.arange(2003,targetyear)  # Now let's include all years until target within hist
# histObs=np.empty((len(histYrsforObs),Grdlen))
#
# for c,year in  enumerate(histYrsforObs):
#     #print(year)
#     file_osisaf = Dataset('/work/ab0995/a270112/data_fesom2/sic/OSISAF_monthly_'+str(year)+'.nc')
#     obs=file_osisaf.variables['obs'][obsTmnth-1,:]
#     histObs[c,:]=obs
#     file_osisaf.close()
#
#
# # Now the bias correction steps are run on each grid point. Let's start by trying just one, then later run a loop?
#
#
# print("Input done, now calibrating")
